





Sending a Versioned Transaction - Phantom Developer Docs














Phantom Developer DocsHomeDeveloper DiscordChangelogTwitterSearch‚åÉKLinksüëªIntroductionIntroductionDeveloper Settingsüü¢SolanaGetting Started With SolanaDetecting the ProviderEstablishing a ConnectionSending a Legacy TransactionSending a Versioned TransactionSigning a MessageError Messages and Codesüî∑Ethereum & PolygonGetting Started with Ethereum and PolygonDetecting the ProviderEstablishing a ConnectionSending a TransactionSigning a MessageProvider API Reference‚õìPhantom DeeplinksPhantom DeeplinksProvider MethodsOther MethodsHandling SessionsSpecifying RedirectsEncryptionLimitationsü§ùLibrary IntegrationsDynamicPrivyRainbowKitwagmiWeb3-OnboardWeb3-React (V8)üõ†Developer PowertoolsPhantom BlocklistSign-In-With (SIW) StandardsSolana Priority FeesSolana Versioned TransactionsWallet Standard‚úÖBest PracticesDisplaying Apps within the Activity TabDisplaying Tokens on SolanaDisplaying Apps within DialogsüôãResourcesFAQDemo ApplicationsCommunity Guides & SDKsLogos & AssetsPowered By GitBookSending a Versioned TransactionOn October 10, 2022, Solana introduced the concept of Versioned Transactions. Currently, the Solana runtime supports two types of transactions: legacy (see Sending a Legacy Transaction) and v0 (transactions that can include Address Lookup Tables (LUTS)).The goal of v0 is to increase the maximum size of a transaction, and hence the number of accounts that can fit in a single atomic transaction. With LUTs, developers can now build transactions with a maximum of 256 accounts, as compared to the limit of 35 accounts in legacy transactions that do not utilize LUTs.For a dive deep on Versioned Transactions, LUTs, and how the above changes affect the anatomy of a transaction, you can read this detailed guide.On this page, we'll go over the following:1.Building a Versioned Transaction2.Signing and Sending a Versioned Transaction3.Building an Address Lookup Table (LUT)4.Extending an Address Lookup Table (LUT)5.Signing and Sending a Versioned Transaction utilising a LUTBuilding a Versioned TransactionVersioned transactions are built in a very similar fashion to legacy transactions. The only difference is that developers should use the VersionedTransaction class rather than the Transaction class.The following example show how to build a simple transfer instruction. Once the transfer instruction is made, a MessageV0 formatted transaction message is constructed with the transfer instruction. Finally, a new VersionedTransaction is created, parsing in the v0 compatible message.createTransactionV0()// create array of instructionsconst instructions = [  SystemProgram.transfer({    fromPubkey: publicKey,    toPubkey: publicKey,    lamports: 10, }),];‚Äã// create v0 compatible messageconst messageV0 = new TransactionMessage({  payerKey: publicKey,  recentBlockhash: blockhash,  instructions,}).compileToV0Message();‚Äã// make a versioned transactionconst transactionV0 = new VersionedTransaction(messageV0);Check out the createTransferTransactionV0() function in our code sandbox for a live example of creating a versioned transaction.Signing and Sending a Versioned TransactionOnce a Versioned transaction is created, it can be signed and sent via Phantom using the signAndSendTransaction method on the provider. The call will return a Promise for an object containing the signature. This is the same way a legacy transaction is sent via the Phantom provider.signAndSendTransaction()const provider = getProvider(); // see "Detecting the Provider"const network = "<NETWORK_URL>";const connection = new Connection(network);const versionedTransaction = new VersionedTransaction();const { signature } = await provider.signAndSendTransaction(versionedTransaction);await connection.getSignatureStatus(signature);You can also specify a SendOptions object as a second argument into signAndSendTransaction() or as an options parameter when using request.For a live demo of signing and sending a Versioned transaction, please refer to the handleSignAndSendTransactionV0() section of our developer sandbox.Building an Address Lookup Table (LUT)Address Lookup Tables (LUTs) can be used to load accounts into table-like data structures. These structures can then be referenced to significantly increase the number of accounts that can be loaded in a single transaction.This lookup method effectively "compresses" a 32-byte address into a 1-byte index value. This "compression" enables storing up to 256 address in a single lookup table for use inside any given transaction.With the @solana/web3.js createLookupTable function, developers can construct the instruction needed to create a new lookup table, as well as determine its address. Once we have the lookup table instruction, we can construct a transaction, sign it, and send it to create a lookup table on-chain. Address lookup tables can be created with either a v0 transaction or a legacy transaction. However, the Solana runtime can only retrieve and handle the additional addresses within a lookup table while using v0 transactions.Here's a code snippet that creates a Lookup Table.createAddressLookupTable()// create an Address Lookup Tableconst [lookupTableInst, lookupTableAddress] = AddressLookupTableProgram.createLookupTable({  authority: publicKey,  payer: publicKey,  recentSlot: slot,});‚Äã// To create the Address Lookup Table on chain:// send the `lookupTableInst` instruction in a transactionconst lookupMessage = new TransactionMessage({  payerKey: publicKey,  recentBlockhash: blockhash,  instructions: [lookupTableInst],}).compileToV0Message();‚Äãconst lookupTransaction = new VersionedTransaction(lookupMessage);const lookupSignature = await signAndSendTransaction(provider, lookupTransaction);Please refer to the handleSignAndSendTransactionV0WithLookupTable() in our code sandbox for a live demo of creating a lookup table.Extending an Address Lookup Table (LUT)Once an Address Lookup Table is created, it can then be extended (i.e. accounts can be appended to the table). Using the @solana/web3.js library, you can create a new extend instruction using the extendLookupTable method. Once the extend instruction is created, it can be sent in a transaction.extendAddressLookupTable()// add addresses to the `lookupTableAddress` table via an `extend` instructionconst extendInstruction = AddressLookupTableProgram.extendLookupTable({  payer: publicKey,  authority: publicKey,  lookupTable: lookupTableAddress,  addresses: [    publicKey,    SystemProgram.programId, // more `publicKey` addresses can be listed here ],});‚Äã// Send this `extendInstruction` in a transaction to the cluster// to insert the listing of `addresses` into your lookup table with address `lookupTableAddress`const extensionMessageV0 = new TransactionMessage({  payerKey: publicKey,  recentBlockhash: blockhash,  instructions: [extendInstruction],}).compileToV0Message();‚Äãconst extensionTransactionV0 = new VersionedTransaction(extensionMessageV0);const extensionSignature = await signAndSendTransaction(provider, extensionTransactionV0);Please refer to the handleSignAndSendTransactionV0WithLookupTable() in our code sandbox for a live demo of extending a lookup table.Signing and Sending a Versioned Transaction utilizing a LUTUp until now, we have:1.Learned how to create a VersionedTransaction2.Created an Address Lookup Table3.Extended the Address Lookup TableAt this point, we are now ready to sign and send a VersionedTransaction utilizing an Address Lookup Table.First, we need to fetch the account of the created Address Lookup Table.getAddressLookupTable()// get the table from the clusterconst lookupTableAccount = await connection.getAddressLookupTable(lookupTableAddress).then((res) => res.value);// `lookupTableAccount` will now be a `AddressLookupTableAccount` objectconsole.log('Table address from cluster:', lookupTableAccount.key.toBase58());We can also parse and read all the addresses currently stores in the fetched Address Lookup Table.Parse and Read addresses// Loop through and parse all the address stored in the tablefor (let i = 0; i < lookupTableAccount.state.addresses.length; i++) { const address = lookupTableAccount.state.addresses[i]; console.log(i, address.toBase58());}We can now create the instructions array with an arbitrary transfer instruction, just the way we did while creating the VersionedTransaction earlier. This VersionedTransaction can then be sent using the signAndSendTransaction() provider function.Untitled// create an array with your desired `instructions`// in this case, just a transfer instructionconst instructions = [  SystemProgram.transfer({    fromPubkey: publicKey,    toPubkey: publicKey,    lamports: minRent, }),];‚Äã// create v0 compatible messageconst messageV0 = new TransactionMessage({  payerKey: publicKey,  recentBlockhash: blockhash,  instructions,}).compileToV0Message([lookupTableAccount]);‚Äã// make a versioned transactionconst transactionV0 = new VersionedTransaction(messageV0);const signature = await signAndSendTransaction(provider, transactionV0);Please refer to the handleSignAndSendTransactionV0WithLookupTable() in our code sandbox for a live demo of signing and sending a versioned transaction utilizing an Address Lookup Table.Solana - PreviousSending a Legacy TransactionNext - SolanaSigning a MessageLast modified 5mo agoCopy linkOn this pageBuilding a Versioned TransactionSigning and Sending a Versioned TransactionBuilding an Address Lookup Table (LUT)Extending an Address Lookup Table (LUT)Signing and Sending a Versioned Transaction utilizing a LUT



