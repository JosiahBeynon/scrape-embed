





Sending a Legacy Transaction - Phantom Developer Docs













Phantom Developer DocsHomeDeveloper DiscordChangelogTwitterSearch‚åÉKLinksüëªIntroductionIntroductionDeveloper Settingsüü¢SolanaGetting Started With SolanaDetecting the ProviderEstablishing a ConnectionSending a Legacy TransactionSending a Versioned TransactionSigning a MessageError Messages and Codesüî∑Ethereum & PolygonGetting Started with Ethereum and PolygonDetecting the ProviderEstablishing a ConnectionSending a TransactionSigning a MessageProvider API Reference‚õìPhantom DeeplinksPhantom DeeplinksProvider MethodsOther MethodsHandling SessionsSpecifying RedirectsEncryptionLimitationsü§ùLibrary IntegrationsDynamicPrivyRainbowKitwagmiWeb3-OnboardWeb3-React (V8)üõ†Developer PowertoolsPhantom BlocklistSign-In-With (SIW) StandardsSolana Priority FeesSolana Versioned TransactionsWallet Standard‚úÖBest PracticesDisplaying Apps within the Activity TabDisplaying Tokens on SolanaDisplaying Apps within DialogsüôãResourcesFAQDemo ApplicationsCommunity Guides & SDKsLogos & AssetsPowered By GitBookSending a Legacy TransactionOnce a web application is connected to Phantom, it can prompt the user for permission to send transactions on their behalf.In order to send a transaction, a web application must:1.Create an unsigned transaction.2.Have the transaction be signed and submitted to the network by the user's Phantom wallet.3.Optionally await network confirmation using a Solana JSON RPC connection.For more information about the nature of Solana transactions, please review the solana-web3.js docs as well as the Solana Cookbook.For a sample Phantom transaction, check out our developer sandbox.Signing and Sending a TransactionOnce a transaction is created, the web application may ask the user's Phantom wallet to sign and send the transaction. If accepted, Phantom will sign the transaction with the user's private key and submit it via a Solana JSON RPC connection. By far the easiest and most recommended way of doing this is by using the signAndSendTransaction method on the provider, but it is also possible to do with request. In both cases, the call will return a Promise for an object containing the signature.signAndSendTransaction()request()const provider = getProvider(); // see "Detecting the Provider"const network = "<NETWORK_URL>";const connection = new Connection(network);const transaction = new Transaction();const { signature } = await provider.signAndSendTransaction(transaction);await connection.getSignatureStatus(signature);const provider = getProvider(); // see "Detecting the Provider"const network = "<NETWORK_URL>";const connection = new Connection(network);const transaction = new Transaction();const { signature } = await provider.request({ method: "signAndSendTransaction", params: { message: bs58.encode(transaction.serializeMessage()), },});await connection.getSignatureStatus(signature);You can also specify a SendOptions object as a second argument into signAndSendTransaction or as an options parameter when using request.For a live demo of signAndSendTransaction, please refer to the handleSignAndSendTransaction section of our developer sandbox.Other Signing MethodsThe following methods are also supported, but are not recommended over signAndSendTransaction. It is safer for users, and a simpler API for developers, for Phantom to submit the transaction immediately after signing it instead of relying on the application to do so. If you use the methods below, Phantom will display a warning message to users.Signing a Transaction (Without Sending)Once a transaction is created, a web application may ask the user's Phantom wallet to sign the transaction without also submitting it to the network. The easiest and most recommended way of doing this is via the signTransaction method on the provider, but it is also possible to do via request. In both cases, the call will return a Promise for the signed transaction. After the transaction has been signed, an application may submit the transaction itself via web3js's sendRawTransaction.signTransaction()request()const provider = getProvider();const network = "<NETWORK_URL>";const connection = new Connection(network);const transaction = new Transaction();const signedTransaction = await provider.signTransaction(transaction);const signature = await connection.sendRawTransaction(signedTransaction.serialize());const provider = getProvider();const network = "<NETWORK_URL>";const connection = new Connection(network);const transaction = new Transaction();const signedTransaction = await provider.request({ method: "signTransaction", params: { message: bs58.encode(transaction.serializeMessage()), },});const signature = await connection.sendRawTransaction(signedTransaction.serialize());Please refer to the handleSignTransaction section of our developer sandbox for an example of signTransaction.Signing Multiple TransactionsIt is also possible to sign and send multiple transactions at once. This is exposed through the signAllTransactions method on the provider.signAllTransactions()request()const signedTransactions = await provider.signAllTransactions(transactions);const message = transactions.map(transaction => { return bs58.encode(transaction.serializeMessage());});const signedTransactions = await provider.request({ method: "signAllTransactions", params: { message },});For an example of signAllTransactions, please refer to the handleSignAllTransactions section of our developer sandbox.Solana - PreviousEstablishing a ConnectionNext - SolanaSending a Versioned TransactionLast modified 6mo agoCopy linkOn this pageSigning and Sending a TransactionOther Signing MethodsSigning a Transaction (Without Sending)Signing Multiple Transactions



